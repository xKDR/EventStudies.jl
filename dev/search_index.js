var documenterSearchIndex = {"docs":
[{"location":"eventstudies/#Possible-API","page":"-","title":"Possible API","text":"","category":"section"},{"location":"eventstudies/","page":"-","title":"-","text":"eventtime_return_ts, success_codes = eventstudy(\n    nifty_ticker_returns_tsframe,\n    market_model,\n    eventtimes = Dates.Date(2019, 5, 23),\n    eventwindow = -5:5,\n    strict = true,\n    verbose = true,\n)","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Types-of-models","page":"Models","title":"Types of models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Modules = [EventStudies]\nFilter = x -> typeof(x) === DataType && x <: EventStudies.AbstractEventStudyModel","category":"page"},{"location":"models/#Model-API","page":"Models","title":"Model API","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"To define a new model, you need to create a struct MyModel <: EventStudies.AbstractEventStudyModel, whose contents can be arbitrary.  Then, you have to implement EventStudies.apply_model(model::MyModel, data::TSFrame), which must return a Tuple of (::TSFrame, ::EventStudies.EventStatus).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EventStudies","category":"page"},{"location":"#EventStudies","page":"Home","title":"EventStudies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EventStudies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EventStudies]","category":"page"},{"location":"#EventStudies.AbstractEventStudyModel","page":"Home","title":"EventStudies.AbstractEventStudyModel","text":"\n\n\n\n","category":"type"},{"location":"#EventStudies.AugmentedMarketModel","page":"Home","title":"EventStudies.AugmentedMarketModel","text":"AugmentedMarketModel(market_returns::TSFrame, additional_returns::TSFrame)\n\nApplies the augmented market model of eventstudy.R to the data.  \n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.BootstrapInference","page":"Home","title":"EventStudies.BootstrapInference","text":"BootstrapInference(sampling_method::Bootstrap.BootstrapSampling)\nBootstrapInference(; replicates = 1000)\n\nCreates an instance of BootstrapSampling for use in inference.   This can be constructed using a Bootstrap.BootstrapSampling subtype directly, or by the convenience keyword constructor which creates a BootstrapInference backed by BasicSampling.\n\nAvailable sampling methods\n\nRandom resampling with replacement (BasicSampling)\nAntithetic resampling, introducing negative correlation between samples (AntitheticSampling)\nBalanced random resampling, reducing bias (BalancedSampling)\nExact resampling, iterating through all unique resamples ([]ExactSampling](@ref)): deterministic bootstrap, suited for small samples sizes\nResampling of residuals in generalized linear models (ResidualSampling, WildSampling)\nMaximum Entropy bootstrapping for dependent and non-stationary datasets (MaximumEntropySampling)\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.ClassicInference","page":"Home","title":"EventStudies.ClassicInference","text":"ClassicInference()\n\nCreates an instance of ClassicInference for use in inference.  This forwards to the T-test from HypothesisTests.jl.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.ConstantMeanReturn","page":"Home","title":"EventStudies.ConstantMeanReturn","text":"ConstantMeanReturn()\n\nEach column is decreased by its mean.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.DataMissing","page":"Home","title":"EventStudies.DataMissing","text":"This means that there was missing data within the window.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.EventStatus","page":"Home","title":"EventStudies.EventStatus","text":"abstract type EventStatus\n\nAn abstract supertype for all event status types.  These are used to indicate the status of an event  (i.e., if it was successful or not, and if so why it was unsuccessful).\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.ExcessReturn","page":"Home","title":"EventStudies.ExcessReturn","text":"ExcessReturn(market_returns::TSFrame)\n\nThis models basic scalar excess return.  \n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.InvalidColname","page":"Home","title":"EventStudies.InvalidColname","text":"This means that the column name was not found in the data.  It prints the column name.  Equivalent to unitmissing in eventstudies.R.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.MarketModel","page":"Home","title":"EventStudies.MarketModel","text":"MarketModel(market_returns::TSFrame)\n\nRegresses \"market\" returns on the variable using a linear model.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.ModelDataMissing","page":"Home","title":"EventStudies.ModelDataMissing","text":"This means that the model was missing data within the event time window.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.ModelIndexIncompatible","page":"Home","title":"EventStudies.ModelIndexIncompatible","text":"This means that the model's index type was incompatible with the event's index type.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.NoModel","page":"Home","title":"EventStudies.NoModel","text":"NoModel()\n\nA very fancy way to say that no decorrelation needs to be done.  No-op.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.Success","page":"Home","title":"EventStudies.Success","text":"Represents a successful event\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.WilcoxonInference","page":"Home","title":"EventStudies.WilcoxonInference","text":"WilcoxonInference(; exact = nothing)\n\nCreates an instance of WilcoxonInference for use in inference.  This forwards to the Wilcoxon inference test from HypothesisTests.jl.\n\nIf exact = nothing, then a heuristic determines whether to use the exact or  approximate Wilcoxon signed-rank test.  If exact = true, then the exact test is used; if exact = false, then the approximate test is used.  If exact = nothing, then a heuristic determines whether to use the exact or approximate tests.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.WrongSpan","page":"Home","title":"EventStudies.WrongSpan","text":"This means that the span of the window extended outside the available data.\n\n\n\n\n\n","category":"type"},{"location":"#EventStudies.apply_model-Tuple{EventStudies.AbstractEventStudyModel, TSFrames.TSFrame}","page":"Home","title":"EventStudies.apply_model","text":"apply_model(model::AbstractEventStudyModel, data::TSFrame)::(::TSFrame, ::EventStatus)\n\nApplies the given model to the provided TSFrame,  and returns a TSFrame (may be empty) along with an EventStatus code.   If the EventStatus code is not Success(), then the returned TSFrame should (and will) be ignored.\n\n\n\n\n\n","category":"method"},{"location":"#EventStudies.inference","page":"Home","title":"EventStudies.inference","text":"inference(::ClassicInference, ts::TSFrame, conf = 0.975)\n\nPerforms classic T-test inference and returns a tuple of vectors (t₀, lower, upper).\n\n\n\n\n\n","category":"function"},{"location":"#EventStudies.inference-2","page":"Home","title":"EventStudies.inference","text":"inference(inf::BootstrapInference, ts::TSFrame, conf = 0.975)\n\nPerforms bootstrap inference and returns a tuple of vectors (t₀, lower, upper).\n\n\n\n\n\n","category":"function"},{"location":"#EventStudies.inference-Union{Tuple{ExactType}, Tuple{WilcoxonInference{ExactType}, TSFrames.TSFrame}, Tuple{WilcoxonInference{ExactType}, TSFrames.TSFrame, Any}} where ExactType","page":"Home","title":"EventStudies.inference","text":"inference(::WilcoxonInference{ExactType}, ts::TSFrame, conf = 0.975) where ExactType\n\nPerforms Wilcoxon signed-rank inference and returns a tuple of vectors (t₀, lower, upper).\n\n\n\n\n\n","category":"method"},{"location":"#EventStudies.inference_surface","page":"Home","title":"EventStudies.inference_surface","text":"inference_surface(infer::InferenceMethod, ts::TSFrame, conf = 0.975; density = 200)::(y_values::Matrix, y_colors::Matrix)\n\n\n\n\n\n","category":"function"},{"location":"#EventStudies.levels_to_returns-Tuple{TSFrames.TSFrame}","page":"Home","title":"EventStudies.levels_to_returns","text":"levels_to_returns(ts::TSFrame)::TSFrame\n\nConverts the data in ts into \"returns\" data, i.e., executes diff(log(ts)) .* 100 on each column of ts.\n\n\n\n\n\n","category":"method"},{"location":"#EventStudies.remap_cumsum-Tuple{TSFrames.TSFrame}","page":"Home","title":"EventStudies.remap_cumsum","text":"remap_cumsum(ts::TSFrame; base = 0)\n\nThis function remaps a time series into its cumulative summation.  The first value of each column is set to base.\n\n\n\n\n\n","category":"method"},{"location":"#EventStudies.remap_levels","page":"Home","title":"EventStudies.remap_levels","text":"remap_levels(ts::TSFrame, base = 100)\n\n\n\n\n\n","category":"function"},{"location":"#EventStudies.to_eventtime_windowed-Union{Tuple{T}, Tuple{TSFrames.TSFrame, Array{Pair{Symbol, T}, 1}, Union{Integer, AbstractVector{<:Integer}}}, Tuple{TSFrames.TSFrame, Array{Pair{Symbol, T}, 1}, Union{Integer, AbstractVector{<:Integer}}, EventStudies.AbstractEventStudyModel}} where T","page":"Home","title":"EventStudies.to_eventtime_windowed","text":"to_eventtime_windowed(\n    return_timeseries::TSFrame, \n    event_times::Vector{Pair{Symbol, T}}, \n    window::Int, \n    model::AbstractEventStudyModel = NoModel(); \n    debug = false\n    ) where T\n\nTakes in a TSFrame of returns, a vector of pairs of column names and event times, and a window size.   It then returns a TSFrame of event windows, where each column is the event return for the corresponding event.  \n\nArguments\n\nreturn_timeseries is a TSFrame which contains the returns of the assets.\nevent_times is a vector of pairs, where the first element is the name of the column in return_timeseries and the second element is the time of the event.  This is in the form :colname => date.\nwindow is the number of data points before and after the event to include in the event window.  It may be an Integer, which describes a range -window:1:window.  It may also be an AbstractVector of Integers or Dates.Periods, which describes the exact window to use.\nmodel is an AbstractEventStudyModel which is used to transform the data before calculating the event returns.\ndebug is a boolean which indicates whether to print debug information.\n\n\n\n\n\n","category":"method"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"EditURL = \"https://github.com/xKDR/EventStudies.jl/blob/main/examples/mwe.jl\"","category":"page"},{"location":"mwe/#A-minimal-example-of-using-EventStudies.jl","page":"Minimal example","title":"A minimal example of using EventStudies.jl","text":"","category":"section"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"This is a basic example of how you can conduct an event study using EventStudies.jl. We create and use synthetic data, show how to use the EventStudies.jl API, and plot it!","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"First, we load the packages:","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"using TSFrames     # EventStudies operates exclusively on TSFrames\nusing EventStudies\nusing CairoMakie        # For plotting","category":"page"},{"location":"mwe/#Creating-a-dataset","page":"Minimal example","title":"Creating a dataset","text":"","category":"section"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"First, we define the TSFrame with the data we want to use. This is a TSFrame with 11 rows, and 2 columns, var1 and var2. They both follow the same general path, linearly increasing to 1, then staying at 1.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"ts1 = TSFrame(\n    DataFrame(\n        :Index => 1:11,\n        :var1 => vcat(LinRange(0, 1, 5), ones(6)),\n        :var2 => vcat(LinRange(0, 1, 6), ones(5)),\n    )\n)","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"For convenience, I've directly referred to everything from EventStudies.jl as EventStudies.*. However, these are all exported, so you don't have to do that.","category":"page"},{"location":"mwe/#Computing-the-event-study","page":"Minimal example","title":"Computing the event study","text":"","category":"section"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"Event studies are conceptually very simple - you take a time series and a list of events, and extract a window around each event.  Then, you perform inference on these measurements to see if the event had a statistically significant effect on the time series, and what that effect was.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"In order to conduct an event study, we need a list of events.  This has to be passed as a Vector of Pair{Symbol, DateType}. The first element of the pair is the name of the column in ts1 that we want to use as the event. The second element is the time of the event.  This can be in any type DateType which TSFrames supports, which for now is restricted to Int, Dates.Date, and Dates.DateTime.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"event_list = [:var1 => 5, :var2 => 6]","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"Our dataset is the form of absolute measurements, levels in EventStudies.jl parlance. However, event studies function best when given data in the form of returns, which are the difference between the log-transformed measurements, or diff(log(ts)).  So, we'll convert our data to returns using the EventStudies.levels_to_returns function. To do this, we'll use the EventStudies.to_eventtime_windowed function, which takes in a TSFrame of returns, a list of events, and a window size.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"eventtime_returns_ts, statuses = EventStudies.to_eventtime_windowed(levels_to_returns(ts1), event_list, 2)","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"The eventtime_returns_ts is a TSFrame with the same columns as ts1, but with a new index.  This index takes the form of \"event time\", which is the time relative to the event. All columns share the same index.  statuses represents the status of each event as a EventStatus object.  In this case, all events were successful.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"Now, we can compute the cumulative returns, and the confidence intervals using the EventStudies.remap_cumsum and EventStudies.inference functions. The remap_cumsum function takes in a TSFrame of returns, and returns a TSFrame of cumulative returns.  You can think of cumulative returns as a mapping from returns back to levels, except renormalized so that everything starts at 0.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"eventtime_cum_ts = EventStudies.remap_cumsum(eventtime_returns_ts)","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"Finally, we conduct inference on the cumulative returns. We'll use the EventStudies.BootstrapInference method, which takes in an inference method (see EventStudies.InferenceMethod) and the return timeseries. In this case, we use the bootstrap method of inference, which calls to Bootstrap.jl.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"confints = EventStudies.inference(EventStudies.BootstrapInference(), eventtime_cum_ts)","category":"page"},{"location":"mwe/#Plotting","page":"Minimal example","title":"Plotting","text":"","category":"section"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"Now, we can plot the results.  We'll use Makie.jl for this.","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"f, a, p = series(eventtime_cum_ts.Index, Matrix(eventtime_cum_ts)'; axis = (xlabel = \"Event time\", ylabel = \"Cumulative return (%)\"))\nband!(eventtime_cum_ts.Index, confints[2], confints[3])\nlines!(eventtime_cum_ts.Index, confints[1])\nf","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"And that's our event study!","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"","category":"page"},{"location":"mwe/","page":"Minimal example","title":"Minimal example","text":"This page was generated using Literate.jl.","category":"page"}]
}
